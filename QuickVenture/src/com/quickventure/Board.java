package com.quickventure;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineEvent;
import javax.sound.sampled.LineListener;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import com.quickventure.images.Animation;
import com.quickventure.images.Sprite;
import com.quickventure.objects.Bullet;
import com.quickventure.objects.GameObject;
import com.quickventure.objects.Character;
import com.quickventure.objects.Item;

public class Board extends JPanel {

	// Auto generated by Eclipse
	private static final long serialVersionUID = 1L;
	
	private final int TARGET_FPS = 80;
	private final long OPTIMAL_TIME = 1000000000 / TARGET_FPS;
	private boolean gameRunning = false;
	private double gain = 0.08; // Game volume control
	private int lastFpsTime = 0;
	private int fps = 0;
	private int windowWidth = 0;
	private int windowHeight = 0;
	private int camX = 0;
	private int camY = 0;
	
	private int objectId = 0;
	private ArrayList<GameObject> grounds = new ArrayList<GameObject>();
	private ArrayList<Character> creatures = new ArrayList<Character>();
	private Character hero = null;
	private ArrayList<Bullet> bullets = new ArrayList<Bullet>();
	private ArrayList<Item> items = new ArrayList<Item>();
	private boolean left = false;
	private boolean right = false;
	private boolean up = false;
	private boolean down = false;
	private boolean shoot = false;
	private String direction = "right";
	private int score = 0;
	private int hpTimer1 = 0; // Standing
	private int hpTimer2 = 0; // Walking
		
	// Animations
	private BufferedImage[] standing_bi = {Sprite.getSprite(0,0), Sprite.getSprite(1,0), Sprite.getSprite(2,0), Sprite.getSprite(3,0), Sprite.getSprite(4,0), Sprite.getSprite(5,0), Sprite.getSprite(6,0), Sprite.getSprite(7,0)};
	private BufferedImage[] walking_bi = {Sprite.getSprite(0,1), Sprite.getSprite(1,1), Sprite.getSprite(2,1), Sprite.getSprite(3,1), Sprite.getSprite(4,1), Sprite.getSprite(5,1)};
	private BufferedImage[] jumping_bi = {Sprite.getSprite(1,3), Sprite.getSprite(2,3)};
	private BufferedImage[] shooting_bi = {Sprite.getSprite(0,2), Sprite.getSprite(1,2), Sprite.getSprite(2,2), Sprite.getSprite(3,2), Sprite.getSprite(4,2), Sprite.getSprite(5,2), Sprite.getSprite(0,3)};
	
	private Animation standing = new Animation(standing_bi, 10);
	private Animation walking = new Animation(walking_bi, 10);
	private Animation jumping = new Animation(jumping_bi, 1);
	private Animation shooting = new Animation(shooting_bi, 10);
	
	private Animation animation = standing;
	
	public Board() {
		KeyListener listener = new KeyListener() {

			@Override
			public void keyPressed(KeyEvent k) {
				switch (k.getKeyCode()){
					case KeyEvent.VK_LEFT:
						left = true;
						break;
					case KeyEvent.VK_RIGHT:
						right = true;
						break;
					case KeyEvent.VK_UP:
						up = true;
						break;
					case KeyEvent.VK_DOWN:
						down = true;
						break;
					case KeyEvent.VK_S:
						shoot = true;
						break;
				}
			}

			@Override
			public void keyReleased(KeyEvent k) {
				switch (k.getKeyCode()){
					case KeyEvent.VK_LEFT:
						left = false;
						break;
					case KeyEvent.VK_RIGHT:
						right = false;
						break;
					case KeyEvent.VK_UP:
						up = false;
						break;
					case KeyEvent.VK_DOWN:
						down = false;
						break;
					case KeyEvent.VK_S:
						shoot = false;
						break;
				}
			}

			@Override
			public void keyTyped(KeyEvent k) {
//				System.out.println("KeyTyped:" + k.getKeyChar());		
			}
		};
		addKeyListener(listener);
		setFocusable(true);
	}
	
	public void runGameLoop() {
		if(!gameRunning){
			Thread loop = new Thread() {
				public void run(){
					gameLoop();
				}
			};
			gameRunning = true;
			loop.start();
		}
	}
	
	private void gameLoop() {
		long lastLoopTime = System.nanoTime();
		windowWidth = getWidth();
		windowHeight = getHeight();
		camX = windowWidth / 2;
		camY = windowWidth / 2;
		initBoard();
		animation.start();
		
		// Start background music
		
		while(gameRunning){
			long now = System.nanoTime();
			long updateLength = now - lastLoopTime;
			lastLoopTime = now;
			double delta = updateLength / (double)OPTIMAL_TIME;
			
//			lastFpsTime += updateLength;
//			fps++;
//			// Prints out number of game updates in a second
//			if(lastFpsTime >= 1000000000) {
//				System.out.println("FPS: " + fps);
////				System.out.println("Delta: " + delta);
//				lastFpsTime = 0;
//				fps = 0;
//			}
			
			gameUpdate(delta);
			
			try{
				Thread.sleep( (lastLoopTime-System.nanoTime() + OPTIMAL_TIME)/1000000 );
			}catch(Exception e){};
		}
		int n = JOptionPane.showConfirmDialog(this, "You have died. Do you want to restart?", null, JOptionPane.YES_NO_OPTION);
		if(n == 0){
			reset();
			runGameLoop();
		}else{
			System.exit(0);
		}
	}
	
	private void gameUpdate(double delta) {
		//Check for user inputs
		if(left){
			direction = "left";
			if(hero.isGrounded()){
				hero.setVX(hero.getVX() - 30);
			}else{
				hero.setVX(hero.getVX() - 10);
			}
		}
		if(right){
			direction = "right";
			if(hero.isGrounded()){
				hero.setVX(hero.getVX() + 30);
			}else{
				hero.setVX(hero.getVX() + 10);
			}
		}
		if(up && hero.isGrounded()){
			hero.setVY(hero.getVY() - 600); // Jump
			hero.setGrounded(false);
			// Play Hero Jump Sound
			try {
				playSound("hero_jump.wav");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		if(down && !hero.isGrounded()){
			hero.setVY(hero.getVY() + 30); // Speeds up fall
		}	
		
		// Shooting logic
		if(hero.shoot(shoot)){
			heroShoot();
		}
		
		// Animation changes
		if(hero.isGrounded() && (left || right) && animation != walking){
			animation.stop();
			animation = walking;
			animation.reset();
			animation.start();
		}else if(hero.isGrounded() && !(left || right) && animation != standing){
			animation.stop();
			animation = standing;
			animation.reset();
			animation.start();
		}else if(!hero.isGrounded()){
			if(animation != jumping){
				animation.stop();
				animation = jumping;
				animation.reset();
			}
			
			if(hero.getVY() > 0 && animation.getCurrentFrame() == 0){
				animation.updateOverride();
			}
		}
		
		if(shoot && hero.isGrounded() && animation == walking && animation.getUpdate()){
			animation.setOverrideFrame(true);
			animation.setFrameOverride(shooting.getFrameAtIndex(animation.getCurrentFrame()));
		}else if(shoot && hero.isGrounded() && animation == standing && animation.getUpdate()){
			animation.setOverrideFrame(true);
			animation.setFrameOverride(shooting.getFrameAtIndex(6));
		}else if(!shoot){
			standing.setOverrideFrame(false);
			walking.setOverrideFrame(false);
		}
		
		// Restore 5 hp/sec while standing still
		if(animation == standing){
			hpTimer2 = 0;
			if(hpTimer1 >= TARGET_FPS){
				hero.takeDamage(-5);
				hpTimer1 = 0;
			}else{
				hpTimer1++;
			}
		}else if(animation == walking){ // Restore 1 hp for moving for 1 seconds
			hpTimer1 = 0;
			if(hpTimer2 >= TARGET_FPS){
				hero.takeDamage(-1);
				hpTimer2 = 0;
			}else{
				hpTimer2++;
			}
		}else{
			hpTimer1 = 0;
			hpTimer2 = 0;
		}
		
		// Creature logic
		for(Character c : creatures){
			if(c.collides(hero)){
				hero.setHealth(0);
			}else if(Math.abs(hero.getX() - c.getX()) <= windowWidth/2 + 50){ // Mob is close enough to see hero
				if(c.chase()){ // Mob half second delay
					int dir;
					if(hero.getX() < c.getX()){ // Hero is to the left of mob
						c.setVX(c.getVX() - 20);
						dir = -1;
					}else{ // Hero is to the right of mob
						c.setVX(c.getVX() + 20); 
						dir = 1;
					}
					mobShoot(c, dir);
				}				
			}else{
				c.setVX(0);
				c.resetShots();
			}
		}
		
		//Update objects		
		hero.getNewLocation(delta);
		//Ground collision detection
		for(GameObject o : grounds){
			if(!hero.isGrounded() && hero.collides(o)){
				hero.setNewLocation(-1, o.getY()-hero.getHeight());
				hero.setGrounded(true);
				hero.setVY(0);
				// Play Hero Lands Sound
				try {
					playSound("hero_land.wav");
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			if(hero.getNX() <= 0){
				hero.setNewLocation(0, -1);
				hero.setVX(0);
			}
		}
		hero.move();
		
		Iterator<Character> ic = creatures.iterator();
		while(ic.hasNext()){
			Character c = ic.next();
			
			if(c.getHealth() <= 0){
				ic.remove();
				score += 5;
				hero.takeDamage(-10);
				// Play Mob Death Sound
				try {
					playSound("mob_death.wav");
				} catch (Exception e) {
					e.printStackTrace();
				}
			}else{
				c.getNewLocation(delta);
				c.move();
			}
		}
		
		Iterator<Bullet> ib = bullets.iterator();
		while(ib.hasNext()){
			Bullet b = ib.next();
			b.getNewLocation(delta);
			if(b.getShooterId() == hero.getId()){
				if(b.checkCollisions(creatures)){
					// Play Mob Hit Sound
					try {
						playSound("mob_hit.wav");
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}else{
				if(b.collides(hero)){
					hero.takeDamage(b.getDamage());
					b.setDestroy(true);
					// Play Hero Hit Sound
					try {
						playSound("hero_hit.wav");
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
			if(b.destroy()){
				ib.remove();
			}else{
				b.move();
			}
		}
		
		Iterator<Item> ii = items.iterator();
		while(ii.hasNext()){
			Item i = ii.next();
			if(i.collides(hero)){
				i.effect(hero);
				ii.remove();
				// Play Hero Mushroom Sound
				try {
					playSound("hero_mushroom.wav");
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		
		
		// Camera movement logic
		int heroX = (int)hero.getX() + hero.getWidth()/2;
		if(heroX > camX){
			camX = heroX;
		}else if(heroX < windowWidth/2){
			camX = windowWidth/2;
		}else if(heroX < camX){
			camX = heroX;
		}
		
		// Player Death Check
		if(hero.getHealth() <= 0){
			gameRunning = false;
			// Play Hero Death Sound
			try {
				playSound("hero_death.wav");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		// Prepare next character animation
		animation.update();
		
		repaint();
	}
	
	public void heroShoot() { 
		Bullet shot;
		if(direction == "right"){
			shot = new Bullet(objectId, hero.getX() + hero.getWidth() - 5, hero.getY() + 33, 10, 10, 5, hero.getId(), windowWidth/2 - 50);
			shot.setVX(700);
		}else{
			shot = new Bullet(objectId, hero.getX(), hero.getY() + 33, 10, 10, 5, hero.getId(), windowWidth/2 - 50);
			shot.setVX(-700);
		}
			
		shot.setColor(Color.black);
		
		bullets.add(shot);
		objectId++;
		// Play Hero Shot Sound
		try {
			playSound("hero_shoot.wav");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public void mobShoot(Character mob, int dir) {
		Bullet shot;
		if(dir == 1){
			shot = new Bullet(objectId, mob.getX() + mob.getWidth(), mob.getY() + 10, 10, 10, 5, mob.getId(), windowWidth/3);
			shot.setVX(300);
		}else{
			shot = new Bullet(objectId, mob.getX(), mob.getY() + 10, 10, 10, 5, mob.getId(), windowWidth/3);
			shot.setVX(-300);
		}
			
		shot.setColor(Color.red);
		
		bullets.add(shot);
		objectId++;
		// Play Mob Shot Sound
		try {
			playSound("mob_shoot.wav");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Override
	public void paintComponent(Graphics g) {
		int camXOffset = camX - windowWidth/2;
		
		super.paintComponent(g);
		
		// Draws hero
		if(direction == "right"){
			g.drawImage(animation.getSprite(), (int)hero.getX() - camXOffset, (int)hero.getY(), hero.getWidth(), hero.getHeight()+11, null);
		}else{
			g.drawImage(animation.getSprite(), (int)hero.getX()+hero.getWidth() - camXOffset, (int)hero.getY(), -1*hero.getWidth(), hero.getHeight()+11, null);
		}
		
		// Draws other stuff
		Iterator<Bullet> ib = bullets.iterator();
		while(ib.hasNext()){
			Bullet b = ib.next();
			b.draw(g, camXOffset);
		}
		
		Iterator<GameObject> ig = grounds.iterator();
		while(ig.hasNext()){
			GameObject o = ig.next();
			o.draw(g, camXOffset);
		}
		
		Iterator<Character> ic = creatures.iterator();
		while(ic.hasNext()){
			Character c = ic.next();
			c.draw(g, camXOffset);
		}
		
		Iterator<Item> ii = items.iterator();
		while(ii.hasNext()){
			Item i = ii.next();
			i.draw(g, camXOffset);
		}
		
		// Draws health and score
		g.drawString("Health: " + hero.getHealth(), windowWidth/8, windowHeight/8);
		g.drawString("Score: " + score, windowWidth*7/8-50, windowHeight/8);
	}
	
	// Creates world and the objects
	private void initBoard() {
		GameObject floor = new GameObject(objectId, 0-windowWidth/2, windowHeight-50, 50, windowWidth*20);
		floor.setCrop(true);
		floor.setImage("ground.png");
		grounds.add(floor);
		objectId++;
		
		hero = new Character(objectId, 50, 100, 83, 80, 20, "Hero");
//		hero.setX(camX - hero.getWidth()/2);
		hero.setAY(2000);
		hero.setHero();
		hero.setAutoFireMode(false);
		objectId++;
		
		// Generates mobs every windowWidth on main ground
		for(int i = windowWidth*3/2; i < floor.getWidth(); i += windowWidth){
			Character c = new Character(objectId, i, floor.getY() - 62, 74, 46, 20, "Mob");
			c.setImage("troll.png");
			c.setMaxSpeed(70);
			
			creatures.add(c);
			objectId++;
		}
		
		// Generates a magic mushroom every windowWidth on the main ground
		for(int i = windowWidth; i < floor.getWidth(); i += windowWidth){
			Item it = new Item(objectId, i, floor.getY() - 40, 40, 40, "heal");
			it.setImage("mushroom.png");
			it.setMaxSpeed(0);
			
			items.add(it);
			objectId++;
		}
	}
	
	private void reset(){
		objectId = 0;
		grounds.clear();
		creatures.clear();
		hero = null;
		bullets.clear();
		items.clear();
		score = 0;
		hpTimer1 = 0;
		hpTimer2 = 0;
		left = false;
		right = false;
		up = false;
		down = false;
		shoot = false;
	}
	
	private void playSound(String s) throws LineUnavailableException, UnsupportedAudioFileException, IOException{
		Clip clip = AudioSystem.getClip();
		File f = new File("sounds/" + s);
		AudioInputStream a = AudioSystem.getAudioInputStream(f);
		clip.open(a);
		FloatControl volume = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
		float dB = (float) (Math.log(gain) / Math.log(10.0) * 20.0);
		volume.setValue(dB);
		
		// Close line when finished playing
		clip.addLineListener(new LineListener() {
            public void update(LineEvent event) {
                if (event.getType() == LineEvent.Type.STOP) {
                    event.getLine().close();
                }
            }
        });
		
		clip.start();
	}
}